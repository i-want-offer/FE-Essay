(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{219:function(v,_,a){"use strict";a.r(_);var t=a(6),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),a("p",[v._v("相信大家都知道 JS 的精度存在问题，像 0.1 + 0.2 是否等于 0.3 这样的已经是被问烂了的面试题，那么为什么 JS 会存在这样的精度问题呢？")]),v._v(" "),a("h1",{attrs:{id:"数字类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数字类型"}},[v._v("#")]),v._v(" 数字类型")]),v._v(" "),a("p",[v._v("ECMAScript 中的 Number 类型使用的是 IEEE754 标准来表示整型和浮点数值。")]),v._v(" "),a("p",[v._v("在 IEEE754 中，规定了四种表示浮点数值的方式：单精度（32位）、双精度（64位）、延伸单精度和延伸双精度。ES 采用的就是双精度，也就是说会用 64 个字节来存储一个浮点数。")]),v._v(" "),a("h1",{attrs:{id:"浮点数转二进制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浮点数转二进制"}},[v._v("#")]),v._v(" 浮点数转二进制")]),v._v(" "),a("p",[v._v("1020 转成二进制为 "),a("code",[v._v("1111111100")])]),v._v(" "),a("p",[v._v("如果是 0.1 转成二进制就是 "),a("code",[v._v("0.00011001100110011....")]),v._v("，是一个无限小数。")]),v._v(" "),a("h1",{attrs:{id:"浮点数存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浮点数存储"}},[v._v("#")]),v._v(" 浮点数存储")]),v._v(" "),a("p",[v._v("虽然 0.1 转成二进制是一个无限小数，但是计算机总要存储。")]),v._v(" "),a("p",[v._v("由于 JS 采用双精度存储，这个标准认为一个浮点数可以表示为：")]),v._v(" "),a("blockquote",[a("p",[v._v("Value = sign * exponent * fraction")])]),v._v(" "),a("p",[v._v("用人话来说就是科学计数法。")]),v._v(" "),a("p",[v._v("比如 -1020，用科学计数法表示就是:")]),v._v(" "),a("blockquote",[a("p",[v._v("-1 * 10^3 * 1.02")])]),v._v(" "),a("p",[v._v("sign 就是 -1，exponent 就是 10^3，fraction 就是 1.02")]),v._v(" "),a("p",[v._v("对于二进制也是一样，以 0.1 的二进制 0.00011001100110011…… 这个数来说：")]),v._v(" "),a("p",[v._v("可以表示为：")]),v._v(" "),a("blockquote",[a("p",[v._v("1 * 2^-4 * 1.1001100110011……")])]),v._v(" "),a("p",[v._v("其中 sign 就是 1，exponent 就是 2^-4，fraction 就是 1.1001100110011……")]),v._v(" "),a("p",[v._v("而当只做二进制科学计数法的表示时，这个 Value 的表示可以再具体一点变成：")]),v._v(" "),a("blockquote",[a("p",[v._v("V = (-1)^S * (1 + Fraction) * 2^E")])]),v._v(" "),a("p",[v._v("(如果所有的浮点数都可以这样表示，那么我们存储的时候就把这其中会变化的一些值存储起来就好了)")]),v._v(" "),a("p",[v._v("我们来一点点看：")]),v._v(" "),a("p",[a("code",[v._v("(-1)^S")]),v._v(" 表示符号位，当 S = 0，V 为正数；当 S = 1，V 为负数。")]),v._v(" "),a("p",[v._v("再看 "),a("code",[v._v("(1 + Fraction)")]),v._v("，这是因为所有的浮点数都可以表示为 1.xxxx * 2^xxx 的形式，前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，直接存后面的 xxxxx 好了，这也就是 Fraction 的部分。")]),v._v(" "),a("p",[v._v("最后再看 "),a("code",[v._v("2^E")])]),v._v(" "),a("p",[v._v("如果是 1020.75，对应二进制数就是 1111111100.11，对应二进制科学计数法就是 1 * 1.11111110011 * 2^9，E 的值就是 9，而如果是 0.1 ，对应二进制是 1 * 1.1001100110011…… * 2^-4， E 的值就是 -4，也就是说，E 既可能是负数，又可能是正数，那问题就来了，那我们该怎么储存这个 E 呢？")]),v._v(" "),a("p",[v._v("我们这样解决，假如我们用 8 位字节来存储 E 这个数，如果只有正数的话，储存的值的范围是 0 ~ 254，而如果要储存正负数的话，值的范围就是 -127~127，我们在存储的时候，把要存储的数字加上 127，这样当我们存 -127 的时候，我们存 0，当存 127 的时候，存 254，这样就解决了存负数的问题。对应的，当取值的时候，我们再减去 127。")]),v._v(" "),a("p",[v._v("所以呢，真到实际存储的时候，我们并不会直接存储 E，而是会存储 E + bias，当用 8 个字节的时候，这个 bias 就是 127。")]),v._v(" "),a("p",[v._v("所以，如果要存储一个浮点数，我们存 S 和 Fraction 和 E + bias 这三个值就好了，那具体要分配多少个字节位来存储这些数呢？IEEE754 给出了标准：")]),v._v(" "),a("p",[a("a",{attrs:{href:"https://camo.githubusercontent.com/961b2b4ca090b3fa649ad71317828c0fe95d71c1/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://camo.githubusercontent.com/961b2b4ca090b3fa649ad71317828c0fe95d71c1/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067",alt:"IEEE754"}}),a("OutboundLink")],1)]),v._v(" "),a("p",[v._v("在这个标准下：")]),v._v(" "),a("p",[v._v("我们会用 1 位存储 S，0 表示正数，1 表示负数。")]),v._v(" "),a("p",[v._v("用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023。")]),v._v(" "),a("p",[v._v("用 52 位存储 Fraction。")]),v._v(" "),a("p",[v._v("举个例子，就拿 0.1 来看，对应二进制是 1 * 1.1001100110011…… * 2^-4， Sign 是 0，E + bias 是 -4 + 1023 = 1019，1019 用二进制表示是 1111111011，Fraction 是 1001100110011……")]),v._v(" "),a("p",[v._v("对应 64 个字节位的完整表示就是：")]),v._v(" "),a("blockquote",[a("p",[v._v("0 01111111011 1001100110011001100110011001100110011001100110011010")])]),v._v(" "),a("p",[v._v("同理, 0.2 表示的完整表示是：")]),v._v(" "),a("blockquote",[a("p",[v._v("0 01111111100 1001100110011001100110011001100110011001100110011010")])]),v._v(" "),a("p",[v._v("所以当 0.1 存下来的时候，就已经发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数。")]),v._v(" "),a("h1",{attrs:{id:"浮点数运算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浮点数运算"}},[v._v("#")]),v._v(" 浮点数运算")]),v._v(" "),a("p",[v._v("关于浮点数的运算，一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。我们来简单看一下 0.1 和 0.2 的计算。")]),v._v(" "),a("p",[v._v("首先是对阶，所谓对阶，就是把阶码调整为相同，比如 0.1 是 "),a("code",[v._v("1.1001100110011…… * 2^-4")]),v._v("，阶码是 -4，而 0.2 就是 "),a("code",[v._v("1.10011001100110...* 2^-3")]),v._v("，阶码是 -3，两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 "),a("code",[v._v("0.11001100110011…… * 2^-3")])]),v._v(" "),a("p",[v._v("接下来是尾数计算:")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("  0.1100110011001100110011001100110011001100110011001101\n+ 1.1001100110011001100110011001100110011001100110011010\n————————————————————————————————————————————————————————\n 10.0110011001100110011001100110011001100110011001100111\n")])])]),a("p",[v._v("我们得到结果为 "),a("code",[v._v("10.0110011001100110011001100110011001100110011001100111 * 2^-3")])]),v._v(" "),a("p",[v._v("将这个结果处理一下，即结果规格化，变成 "),a("code",[v._v("1.0011001100110011001100110011001100110011001100110011(1) * 2^-2")])]),v._v(" "),a("p",[v._v("括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。")]),v._v(" "),a("p",[v._v("再然后是舍入，四舍五入对应到二进制中，就是 0 舍 1 入，因为我们要把括号里的 1 丢了，所以这里会进一，结果变成")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("1.0011001100110011001100110011001100110011001100110100 * 2^-2\n")])])]),a("p",[v._v("本来还有一个溢出判断，因为这里不涉及，就不讲了。")]),v._v(" "),a("p",[v._v("所以最终的结果存成 64 位就是")]),v._v(" "),a("blockquote",[a("p",[v._v("0 01111111101 0011001100110011001100110011001100110011001100110100")])]),v._v(" "),a("p",[v._v("将它转换为10进制数就得到 "),a("code",[v._v("0.30000000000000004440892098500626")])]),v._v(" "),a("p",[v._v("因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3")])])}),[],!1,null,null,null);_.default=e.exports}}]);